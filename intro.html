<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="ja-JP">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-2022-jp">
  <meta http-equiv="Content-Language" content="ja-JP">
  <link rel="stylesheet" type="text/css" href="rhg.css">
  <link rev="made" href="mailto:aamine@loveruby.net">
<title>序章 導入</title></head>
<body>

<h1>序章 導入</h1>

<h2>Rubyの特徴</h2>

<p>
読者の中には既にRubyに慣れ親しんでいる人もいるだろうが、そうでない人も
たくさんいるだろう（そうであってほしい）。まずはそのような人達のために
Rubyの特徴をおおざっぱにまとめる。
</p>

<p>
以下、言語仕様としてのRuby言語を大文字で「Ruby」、その実装としての
<code>ruby</code>コマンドを小文字で「<code>ruby</code>」と書き分けて示す。
</p>

<h4>開発形態</h4>

<p>
Rubyは、まつもとゆきひろ氏個人の手によって作成されている言語である。
CやJavaやSchemeのように標準があるわけではない。その仕様は<code>ruby</code>という
実装によって示されるだけであり、しかも常に変化している。良くも悪くも
自由なのだ。
</p>

<p>
また<code>ruby</code>がフリーソフトウェアである……つまりソースコードが公開されていること、
しかも無料で配布されていること、の二点は書いておかないといけないだろう。
そのような条件だからこそ本書のような試みも成立するわけだ。
</p>

<p>
正確なライセンスは本体に含まれる<code>README</code>と<code>LEGAL</code>を読んでもらうとして、
とりあえずは以下のようなことはできるということを覚えておいて
もらえばよい。
</p>

<ul>
<li><code>ruby</code>のソースコードを再配布できる。</li>
<li><code>ruby</code>のソースコードを改変できる。</li>
<li>改変したソースコードを配布できる。</li>
</ul>

<p>
いずれの場合も特別な許諾や料金は必要ない。
</p>

<p>
なお本書はオリジナルの<code>ruby</code>を読むのが目的なので特に断らない限り変更なし
のソースである。ただし空白・改行・コメントの追加削除だけは断りなしに行っ
た。
</p>

<h4>保守的である</h4>

<p>
Rubyはとても保守的な言語である。いろいろな言語で検証され使い古されたも
のばかりを選んで搭載しており、新奇な機能や実験的な仕様はあまり付いてい
ない。だからRubyはどちらかというと実用重視のプログラマに受ける傾向があ
り、SchemeやHaskellラヴな根っからのハッカーには、少なくともちょっと見
には、受けが良くないようだ。
</p>

<p>
ライブラリもそうだ。新しい機能には省略無しのわかりやすい名前が付いてい
るのだが、CやPerlのライブラリにある名前はそのまま使われている。例えば
<code>printf</code>や<code>getpwent</code>、<code>sub</code>、<code>tr</code>など。
</p>

<p>
また実装においても保守的だ。速度のためにアセンブラを使ったりすることは
なく、スピードと移植性が相反するときは常に移植性の高い方法が使われる。
</p>

<h4>オブジェクト指向言語である</h4>

<p>
Rubyはオブジェクト指向言語である。これはRubyの特徴として絶対に外すこと
はできない。
</p>

<p>
オブジェクト指向とは何なのか、という話は本書にとっては筋違いなので省略
する。「Rubyのオブジェクト指向」について言えば、これから解説するコード
が表現しようとしているものがソレである。
</p>

<h4>スクリプト言語である</h4>

<p>
Rubyはスクリプト言語である。これもRubyの特徴として絶対に外すことはでき
ないらしい。Rubyを紹介するときには「オブジェクト指向スクリプト言語」
という枕詞を付けないとみんなに満足してもらえない。
</p>

<p>
しかし、スクリプト言語とはどういう言語のことだろうか。どうもこれがはっき
りしない。例えばTcl/Tkの作者のJohn K.Ousterhoutは「UNIXで<code>#!</code>を使って
実行できる言語」という定義を与えているし、他にも人によって定義はいろい
ろある。一行で役に立つプログラムが書けること、コマンドラインからプログ
ラムのファイルを渡して実行できること、などなど。
</p>

<p>
しかし筆者はあえて別の定義を使うことにする。なぜかというと、スクリプト
言語が「何」か、なんてことには興味がないからである。ある言語をスクリプ
ト言語と呼ぶときの筆者の基準はただ一つ、その言語をスクリプト言語と呼ん
でも文句を言われないかどうかだ。これを満たすために、筆者は以下のように
「スクリプト言語」の意味を定義する。
</p>

<p class="center">
その言語の作者がスクリプト言語と呼ぶもの。
</p>

<p>
この定義なら絶対に間違いようはない。そしてRubyはこの点を確かに満たす。
だから筆者もRubyをスクリプト言語と呼ぶことにする。
</p>

<h4>インタプリタである</h4>

<p>
<code>ruby</code>はインタプリタである。それは事実だ。ではなぜインタプリタなのだろう。
例えばコンパイラではだめなのだろうか。それはきっとコンパイラよりもイン
タプリタのほうが良い……少なくともRubyにとっては良い、ことがあるからに
違いない。ではインタプリタのどういうところが良かったのだろうか。
</p>

<p>
それを考える前段階として、まずインタプリタとコンパイラの違うところを考
えてみよう。プログラムが実行される過程を理論的に比べてみるだけなら、イ
ンタプリタ言語だろうとコンパイル言語だろうと違いはない。機械語にコンパ
イルしたところでCPUにインタープリットしてもらって動くのだから、インタ
プリタで動いていると言えないこともない。ではどこで違いが出るかと言えば、
それはもっと現実的なところ、つまり開発の過程である。
</p>

<p>
そういうことを言うとすぐに「インタプリタはコンパイルしなくていいので手
間が減って開発が楽」という決まり文句を出す人がいる。だがそれは正確では
ないと筆者は考える。コンパイル言語だろうとなんだろうとコンパイルの過程
を開発者に見せないような工夫は可能である。実際にDelphiなんかはF5一発で
実行できるし、コンパイルに時間がかかると言ってもそれはコンパイルする
プログラムが大きかったり、最適化していたりするのが原因だ。コンパイルし
ていることそれ自体が悪いわけではない。
</p>

<p>
ではなぜインタプリタとコンパイラのイメージがこれほどまでに違うのだろう
か。それはこれまでの言語開発者が自分の言語の特徴によって両者の実装を使
いわけてきたからだと思う。即ち、比較的小規模な、日常のツールとしての
言語を構築する場合はインタプリタ。多人数で開発を行う、巨大で確実性が要
求されるプログラムのための言語を構築する場合はコンパイラ。そうなったの
は速度のせいもあるだろうし、言語の作りやすさの違いもあるだろう。
</p>

<p>
だから、「インタプリタだから」手軽だというのは大いなる神話だと筆者は思
う。言語がインタプリタだと使いやすいのではなく、使いやすい言語を作ろう
と思うと自然とインタプリタに足が向くのである。
</p>

<p>
それはともあれ、<code>ruby</code>がインタプリタであるというのは本書の行方を左右する
重要な事実であるのでここで一度強調しておく。それだから使いやすいのかど
うかなんて知らないが、とにかく<code>ruby</code>はインタプリタとして実現されているのだ。
</p>

<h4>移植性が高い</h4>

<p>
根本的にインターフェイスがUNIX中心であるという問題はあるものの、それを
差し引いても<code>ruby</code>は移植性が高いと言えるだろう。あまりに特殊なライブラリ
を要求することもないし、アセンブラでゴリゴリ書いているところもほとんど
ない。だから新しいプラットフォームにもわりと素直に持っていける。具体的
には以下のようなプラットフォームで動いている。
</p>

<ul>
<li>Linux</li>
<li>Win32（Windows 95、98、Me、NT、2000、XP）</li>
<li>Cygwin</li>
<li>djgpp</li>
<li>FreeBSD</li>
<li>NetBSD</li>
<li>OpenBSD</li>
<li>BSD/OS</li>
<li>Mac OS X</li>
<li>Solaris</li>
<li>Tru64 UNIX</li>
<li>HP-UX</li>
<li>AIX</li>
<li>VMS</li>
<li>UX/4800</li>
<li>BeOS</li>
<li>OS/2 (emx)</li>
<li>Psion</li>
</ul>

<p>
作者のまつもとさんのメインマシンはLinuxだそうで、Linuxならばどんなタイ
ミングでコンパイルしてもまず大丈夫だ。
</p>

<p>
また基本的に（普通の）UNIX系ならば安定動作を期待できる。パッケージの追
従の早さも考えると、現時点では<code>ruby</code>をいじるなら各種PC UNIXが最も有利な
環境だろう。
</p>

<p>
一方、問題が起こりやすいのはなんと言ってもWin32環境である。対象とする
OSのモデルがまるきり違うため、マシンスタックやリンカの周辺で問題が起き
やすい。もっとも最近はWindowsハッカー達の手によって随分対応が改善され
てきた。筆者もWindows 2000とMeでネイティブ版を使っているが、一度動いて
しまえば特に落ちやすいとかいうことはない。Windowsにおいて問題となるの
はむしろ仕様面のギャップなのだと思う。
</p>

<p>
この他で興味がある人が多そうなOSと言えばMac OS（v9以前）と、Palmなどの
ハンドヘルド系だろう。
</p>

<p>
<code>ruby 1.2</code>のころまではMac OSにも対応していたのだが最近は開発が止まってし
まっておりコンパイルすら通らない。最大の原因はMac OSのコンパイル環境と
開発者が減ってしまったことである。ただしMac OS Xは中身がUNIXなの
でほとんど問題はない。
</p>

<p>
またPalmで動かないかという話は何度か出ているのだが、移植できたという話
は聞いていない。この場合はどう実装するかよりも<code>stdio</code>をどうするかなど仕
様上の問題を解決するほうが難しいのではないだろうか。Psionには移植したと
いう話題が出ていた（[ruby-list:36028]）。
</p>

<p>
それから最近とみに騒がしいJavaや.NETのVMはどうだろう。これについては
実装とからめて話したいので終章で改めて話すことにする。
</p>

<h4>自動メモリ管理</h4>

<p>
機能的にはガーベージコレクション、GCと言う。C言語で言えば<code>malloc()</code>しても
<code>free()</code>しなくていいという機能である。使っていないメモリはシステムが勝手に
検出して解放してくれるのだ。これはあまりに便利な機能で、GCに慣れてしま
うともはや手動のメモリ管理なぞやる気にもならない。
</p>

<p>
最近の言語ではGCはたいてい標準装備になっているのでかなり普遍的な話題だ
し、アルゴリズムにも工夫の余地がたくさんあって楽しい。
</p>

<h4>変数は型無し</h4>

<p>
Rubyの変数には型がない。理由は、オブジェクト指向最強の武器の一つ、
ポリモーフィズム（多態性）が使いやすくなるからだろう。
もちろん型有りの言語でポリモーフィズムが使えないわけではない。
あくまで「使いやすくなる」だけだ。
</p>

<p>
またこの場合の使いやすさとは「お手軽」とほぼ同義語で、それは非常に重要
な場合もあるしどうでもいいこともある。しかし「お手軽簡単ラクチン」を目
指すならこれは間違いなく長所であり、Rubyはそれを目指している。
</p>

<h4>ほとんどの文法要素が式</h4>

<p>
この項はすぐにはわからないと思うので少し説明する。
例えばC言語では次のようなプログラムは文法エラーになる。
</p>

<pre class="emlist">
result = if (cond) { process(val); } else { 0; }
</pre>

<p>
なぜならCの文法上では<code>if</code>は文だからだ。しかし次のようには書ける。
</p>

<pre class="emlist">
result = cond ? process(val) : 0;
</pre>

<p>
こう書けるのは条件演算子（<code>a?b:c</code>）が文法上、式に入るからだ。
</p>

<p>
一方Rubyでは<code>if</code>が式なので次のように書いてもよい。
</p>

<pre class="emlist">
result = if cond then process(val) else nil end
</pre>

<p>
大雑把に言うと、関数やメソッドの引数にできるものは式だと思っていい。
</p>

<p>
もちろん「ほとんどの文法要素が式」という言語は他にもいろいろある。例えば
Lispはその最たるものだ。このあたりの特徴からなんとなく「RubyはLispに似
てる」と感じる人が多いようである。
</p>

<h4>イテレータ</h4>

<p>
Rubyにはイテレータがある。イテレータとは何か。いやその前にイテレータと
いう言葉は最近嫌われているので別の言葉を使うべきかもしれない。だがい
い言葉を思いつかないので当面イテレータと呼ぶことにする。
</p>

<p>
それでイテレータとは何か。高階の関数を知っているなら、とりあえずはそれ
と似たようなものだと思っておけばいい。Cで言えば関数ポインタを引数
に渡すやつである。C++で言えばSTLにある<code>Iterator</code>の操作部分までをメソッド
に封入したものである。shやPerlを知っているのなら、独自に定義できる
<code>for</code>文みたいなもんだと思って見てみるといい。
</p>

<p>
もっともあくまでここに挙げたのは全て「似たようなもの」であって、どれも
Rubyのイテレータと似てはいるが、同じでは、全くない。いずれその時が来た
らもう少し厳密な話をしよう。
</p>

<h4>C言語で書いてある</h4>

<p>
Cで書いたプログラムなどいまどき珍しくもないが、特徴であることは間違い
ない。少なくともHaskellやPL/Iで書いてあるわけではないので一般人にも
読める可能性が高い（本当にそうかどうかはこれから自分で確かめてほしい）。
</p>

<p>
それからC言語と言っても<code>ruby</code>が対象としているのは基本的にK&amp;R Cだ。
少し前まではK&amp;R onlyの環境が、たくさんとは言わないが、それなりにあったからだ。
しかしさすがに最近はANSI Cが通らない環境はなくなってきており技術的には
ANSI Cに移っても特に問題はない。だが作者のまつもとさん個人の趣味もあっ
てまだK&amp;Rスタイルを通している。
</p>

<p>
そんなわけで関数定義は全てK&amp;Rスタイルだし、プロトタイプ宣言もあまり真面
目に書かれていない。<code>gcc</code>でうっかり<code>-Wall</code>を付けると大量に警告が出て
くるとか、
C++コンパイラでコンパイルするとプロトタイプが合わないと怒られてコンパ
イルできない……なんて話がポロポロとメーリングリストに流れている。
</p>

<h4>拡張ライブラリ</h4>

<p>
RubyのライブラリをCで書くことができ、Rubyを再コンパイルすることなく
実行時にロードできる。このようなライブラリを「Ruby拡張ライブラリ」
または単に「拡張ライブラリ」と言う。
</p>

<p>
単にCで書けるだけでなくRubyレベルとCレベルでのコードの表現の差が小さい
のも大きな特徴である。Rubyで使える命令はほとんどそのままCでも使うこと
ができる。例えば以下のように。
</p>

<pre class="emlist">
# メソッド呼び出し
obj.method(arg)                                 # Ruby
rb_funcall(obj, rb_intern("method"), 1, arg);   # C

# ブロック呼び出し
yield arg        # Ruby
rb_yield(arg);   # C

# 例外送出
raise ArgumentError, 'wrong number of arguments'       # Ruby
rb_raise(rb_eArgError, "wrong number of arguments");   # C

# オブジェクトの生成
arr = Array.new             # Ruby
VALUE arr = rb_ary_new();   # C
</pre>

<p>
拡張ライブラリを書くうえでは非常に楽をできていいし、現実に
このことが代えがたい<code>ruby</code>の長所にもなっている。しかしそのぶん
<code>ruby</code>の実装にとっては非常に重い足枷となっており、随所にその
影響を見ることができる。特にGCやスレッドへの影響は顕著である。
</p>

<h4>スレッド</h4>

<p>
Rubyにはスレッドがある。さすがに最近はスレッドを知らない人はほとんどい
ないと思うのでスレッド自体に関する説明は省略する。以下はもう少し細かい
話だ。
</p>

<p>
<code>ruby</code>のスレッドはオリジナルのユーザレベルスレッドである。この実装の
特徴は、仕様と実装、両方の移植性が非常に高いことである。なにしろDOS上で
さえスレッドが動き、どこでも同じ挙動で使えるのだ。この点を<code>ruby</code>の最大の
長所として挙げる人も多い。
</p>

<p>
しかし<code>ruby</code>スレッドは凄まじい移植性を実現した反面で速度をおもいきり犠牲
にしている。どのくらい遅いかというと、世の中に数あるユーザレベルスレッ
ドの実装の中でも一番遅いのではないか、というくらい遅い。これほど<code>ruby</code>の
実装の傾向を明確に表しているところもないだろう。
</p>



















<h2>ソースコードを読む技術</h2>

<p>
さて。<code>ruby</code>の紹介も終わっていよいよソースコード読みに入ろうか、というと
ころだが、ちょっと待ってほしい。
</p>

<p>
ソースコードを読む、というのはプログラマならば誰しもやらなければいけな
いことだが、その具体的な方法を教えてもらえることはあまりないのではない
だろうか。どうしてだろう。プログラムが書けるなら読むのも当然できるとい
うのだろうか。
</p>

<p>
しかし筆者には人の書いたプログラムを読むことがそんなに簡単なことだとは
思えない。プログラムを書くのと同じくらい、読むことにも技術や定石がある
はずだし、必要だと考える。そこで<code>ruby</code>を読んでいく前にもう少し一般的に、
ソースコードを読むにはどういう考えかたをすればいいのか、整理することに
しよう。
</p>


<h3>原則</h3>

<p>
まずは原則について触れる。
</p>

<h4>目的の決定</h4>

<blockquote>
「ソースコードを読むための極意」は『目的をもって読む』ことです。
</blockquote>

<p>
これはRuby作者のまつもとさんの言だ。なるほど、この言葉には非常にうなず
けるものがある。「カーネルくらいは読んどかなきゃいかんかなあ」と思って
ソースコードを展開したり解説本を買ったりしてはみたものの、いったいどう
していいのかわからないまま放ってしまった、という経験のある人は多いので
はないだろうか。その一方で、「このツールのどこかにバグがある、とにかく
これを速攻で直して動かさないと納期に間に合わない」……というときには他
人のプログラムだろうとなんだろうと瞬く間に直せてしまうこともあるのでは
ないだろうか。
</p>

<p>
この二つのケースで違うのは、意識の持ちかたである。自分が何を知ろうと
しているのかわからなければ「わかる」ことはありえない。だからまず自分が
何を知りたいのか、それを明確に言葉にすることが全ての第一歩である。
</p>

<p>
だがこれだけではもちろん「技術」たりえない。「技術」とは、意識すれば誰に
でもできるものでなければならないからだ。続いて、この第一歩から最終的に
目的を達成するところまで敷衍する方法について延べる。
</p>

<h4>目的の具体化</h4>

<p>
いま「<code>ruby</code>全部を理解する」を最終目標に決めたとしよう。これでも「目的を
決めた」とは言えそうだが、しかし実際にソースコードを読む役に立たないこ
とは明らかである。具体的な作業には何にもつながっていないからだ。従って
まずはこの曖昧な目標を具体的なところまで引きずり下ろさなければならない。
</p>

<p>
どうすればいいだろうか。まず第一に、そのプログラムを書いた人間になった
つもりで考えてみることだ。そのときにはプログラムを作るときの知識が流用
できる。例えば伝統的な「構造化」プログラムを読むとしたら、こちらも
構造化プログラムの手法に則って考えるようにする。即ち目的を徐々に徐々に分割
していく。あるいはGUIプログラムのようにイベントループに入ってグルグル
するものならば、とりあえず適当にイベントループを眺めてからイベントハン
ドラの役割を調べてみる。あるいはMVC（Model View Controler）のMをまず調
べてみる。
</p>

<p>
第二に解析の手法を意識することだ。誰しも自分なりの解析方法というのはそ
れなりに持っていると思うが、それは経験と勘に頼って行われていることが多
い。どうしたらうまくソースコードを読めるのか、そのこと自体を考え、意識
することが非常に重要である。
</p>

<p>
ではそのような手法にはどんなものがあるだろうか。それを次に説明する。
</p>



<h3>解析の手法</h3>

<p>
ソースコードを読む手法は大雑把に言って静的な手法と動的な手法の二つに分
類できる。静的な手法とはプログラムを動かさずソースコードを読んだり解析
したりすること。動的な手法とはデバッガなどのツールを使って実際の動きを
見ることだ。
</p>

<p>
プログラムを調査するときはまず動的な解析から始めたほうがよい。なぜなら
それは「事実」だからだ。静的な解析では現実にプログラムを動かしていない
のでその結果は多かれ少なかれ「予想」になってしまう。真実を知りたいのな
らばまず事実から始めるべきなのだ。
</p>

<p>
もちろん動的な解析の結果が本当に事実であるかどうかはわからない。デバッガがバ
グっているかもしれないし、CPUが熱暴走しているかもしれない。自分が設定
した条件が間違っているかもしれない。しかし少なくとも静的解析よりは動的
な解析の結果のほうが事実に近いはずである。
</p>



<h3>動的な解析</h3>

<h4>対象プログラムを使う</h4>

<p>
これがなければ始まらない。そもそもそのプログラムがどういうものなのか、
どういう動作をすべきなのか、あらかじめ知っておく。
</p>

<h4>デバッガで動きを追う</h4>

<p>
例えば実際にコードがどこを通ってどういうデータ構造を作るか、なんていう
ことは頭の中で考えているよりも実際にプログラムを動かしてみてその結果を
見たほうが早い。それにはデバッガを使うのが簡単だ。
</p>

<p>
実行時のデータ構造を絵にして見られるとさらに嬉しいのだが、そういうツー
ルはなかなかない（特にフリーのものは少ない）。比較的単純な構造のスナッ
プショットくらいならテキストでさらっと書き出し
<code>graphviz</code>\footnote{<code>graphviz</code>……添付CD-ROMの<code>doc/graphviz.html</code>参照}の
ようなツールを使って絵にすることもできそうだが、汎用・リアルタイムを
目指すとかなり難しい。
</p>

<h4>トレーサ</h4>

<p>
コードがどの手続きを通っているか調査したければトレーサを使えばいい。
C言語なら
<code>ctrace</code>\footnote{<code>ctrace</code>……<code>http://www.vicente.org/ctrace</code>}と
いうツールがある。
またシステムコールのトレースには
<code>strace</code>\footnote{<code>strace</code>……<code>http://www.wi.leidenuniv.nl/~wichert/strace/</code>}、
<code>truss</code>、<code>ktrace</code>と言ったツールがある。
</p>

<h4>printしまくる</h4>

<p>
<code>printf</code>デバッグという言葉があるが、この手法はデバッグでなくても役に立つ。
特定の変数の移り変わりなどはデバッガでチマチマ辿ってみるよりもprint文を
埋め込んで結果だけまとめて見るほうがわかりやすい。
</p>

<h4>書き換えて動かす</h4>

<p>
例えば動作のわかりにくいところでパラメータやコードを少しだけ変えて動
かしてみる。そうすると当然動きが変わるから、コードがどういう意味なのか
類推できる。
</p>

<p>
言うまでもないが、オリジナルのバイナリは残しておいて
同じことを両方にやってみるべきである。
</p>



<h3>静的な解析</h3>

<h4>名前の大切さ</h4>

<p>
静的解析とはつまりソースコードの解析だ。そしてソースコードの解析とは名
前の調査である。ファイル名・関数名・変数名・型名・メンバ名など、プログ
ラムは名前のかたまりだ。名前はプログラムを抽象化する最大の武器なのであ
たりまえと言えばあたりまえだが、この点を意識して読むとかなり効率が違う。
</p>

<p>
またコーディングルールについてもあたりをつけておきたい。例えばCの関数
名なら<code>extern</code>関数にはプリフィクスを使っていることが多く、関数の種類を見
分けるのに使える。またオブジェクト指向様式のプログラムだと関数の所属情
報がプリフィクスに入っていることがあり、貴重な情報になる。
（例：<code>rb_str_length</code>）
</p>

<h4>ドキュメントを読む</h4>

<p>
内部構造を解説したドキュメントが入っていることもある。
特に「<code>HACKING</code>」といった名前のファイルには注意だ。
</p>

<h4>ディレクトリ構造を読む</h4>

<p>
どういう方針でディレクトリが分割されているのか見る。
そのプログラムがどういう作りになっているのか、
どういうパートがあるのか、概要を把握する。
</p>

<h4>ファイル構成を読む</h4>

<p>
ファイルの中に入っている関数（名）も合わせて見ながら、
どういう方針でファイルが分割されているのか見る。ファイル名は
有効期間が非常に長いコメントのようなものであり、注目すべきである。
</p>

<p>
さらに、ファイルの中にまたモジュールがある場合、モジュールを構成する関
数は近くにまとまっているはずだ。つまり関数の並び順からモジュール構成
を見付けることができる。
</p>

<h4>略語の調査</h4>

<p>
わかりにくい略語があればリストアップしておいて早めに調べる。
例えば「GC」と書いてあった場合、それがGarbage Collectionなのか
それともGraphic Contextなのかで随分と話が違ってしまう。
</p>

<p>
プログラム関係の略語はたいてい単語の頭文字を取るとか、単語から母音を落とす、
という方法で作られる。特に対象プログラムの分野で有名な略語は問答無用で
使われるのであらかじめチェックしておこう。
</p>

<h4>データ構造を知る</h4>

<p>
データとコードが並んでいたら、まずデータ構造から調べるべきである。つま
りCならヘッダファイルから眺めるほうが、たぶんいい。そのときはファイル
名から想像力を最大限に働かせよう。例えば言語処理系で<code>frame.h</code>というファ
イルがあったら恐らくスタックフレームの定義だ。
</p>

<p>
また構造体の型とメンバ名だけでも随分といろいろなことがわかる。例え
ば構造体の定義中に自分の型へのポインタで<code>next</code>というメンバがあればリンク
リストだろうと想像できる。同様に、<code>parent</code>・<code>children</code>・<code>sibling</code>と言った要
素があれば十中八九ツリーだ。<code>prev</code>ならスタックだろう。
</p>

<h4>関数同士の呼び出し関係を把握する</h4>

<p>
関数同士の関係は名前の次に重要な情報だ。呼び出し関係を表現したものを
特に「コールグラフ」と言うが、これは非常に便利である。このへんは
ツールを活用したい。
</p>

<p>
ツールはテキストベースで十分だが、図にしてくれれば文句無しだ。
ただそういう便利なものはなかなかない（特にフリーのものは少ない）。
筆者が本書のために<code>ruby</code>を解析したときは、小さなコマンド言語と
パーサを適当にRubyで書き、<code>graphviz</code>というツールに渡して半自動生成した。
</p>

<h4>関数を読む</h4>

<p>
動作を読んで、関数のやることを一言で説明できるようにする。関数関連図を
見ながらパートごとに読んでいくのがいい。
</p>

<p>
関数を読むときに重要なのは「何を読むか」ではなく「何を読まないか」であ
る。どれだけコードを削るかで読みやすさが決まると言ってよい。具体的に何
を削ればいいか、というのは実際に見せてみないとわかりづらいので本文で解
説する。
</p>

<p>
それとコーディングスタイルが気にいらないときは<code>indent</code>のようなツールを
使って変換してしまえばいい。
</p>

<h4>好みに書き換えてみる</h4>

<p>
人間の身体というのは不思議なもので、できるだけ身体のいろんな場所を使い
ながらやったことは記憶に残りやすい。パソコンのキーボードより原稿用紙の
ほうがいい、という人が少なからずいるのは、単なる懐古趣味ではなくそうい
うことも関係しているのではないかと思う。
</p>

<p>
そういうわけで単にモニタで読むというのは非常に身体に残りにくいので、
書き換えながら読む。そうするとわりと早く身体がコードに馴染んでくること
が多い。気にくわない名前やコードがあったら書き換える。わかりづらい略語
は置換して省略しないようにしてしまえばよい。
</p>

<p>
ただし当然のことだが書き換えるときはオリジナルのソースは別に残しておき、
途中で辻褄が合わないと思ったら元のソースを見て確認すること。でないと自
分の単純ミスで何時間も悩む羽目になる。それに書き換えるのはあくまで馴染
むためであって書き換えること自体が目的ではないので熱中しすぎないように
注意してほしい。
</p>



<h3>歴史を読む</h3>

<p>
プログラムにはたいてい変更個所の履歴を書いた文書が付いている。例えば
GNUのソフトウェアだと必ず<code>ChangeLog</code>というファイルがある。これは
「プログラムがそうなっている理由」を知るのには最高に役に立つ。
</p>

<p>
またCVSやSCCSのようなバージョン管理システムを使っていてしかもそれにア
クセスできる場合は、<code>ChangeLog</code>以上に利用価値が高い。CVSを例に取ると、特
定の行を最後に変更した場所を表示する<code>cvs annotate</code>、指定した版からの差分
を取る<code>cvs diff</code>などが便利だ。
</p>

<p>
さらに、開発用のメーリングリストやニュースグループがある場合はその過去
ログを入手してすぐに検索できるようにしておく。変更の理由がズバリ載って
いることが多いからだ。もちろんWeb上で検索できるならそれでもいい。
</p>



<h3>静的解析用ツール</h3>

<p>
いろいろな目的のためにいろいろなツールがあるので一口には言えないが、筆
者が一つだけ選ぶとしたら<code>global</code>をお勧めする。なんと言っても他の用途に応
用しやすい作りになっているところがポイントだ。例えば同梱されている
<code>gctags</code>は本当はタグファイルを作るためのツールなのだが、
これを使ってファイルに含まれる関数名のリストを取ることもできる。
</p>

<pre class="screen">
~/src/ruby % gctags class.c | awk '{print $1}'
SPECIAL_SINGLETON
SPECIAL_SINGLETON
clone_method
include_class_new
ins_methods_i
ins_methods_priv_i
ins_methods_prot_i
method_list
        ：
        ：
</pre>

<p>
とは言えこれはあくまでも筆者のお勧めなので読者は自分の好きなツールを使っ
てもらえばいい。ただその時は最低でも次の機能を備えているものを選ぶように
すべきだ。
</p>

<ul>
<li>ファイルに含まれる関数名をリストアップする</li>
<li>関数名や変数名から位置を探す（さらにそこに飛べるとなおよい）</li>
<li>関数クロスリファレンス</li>
</ul>
























<h2>ビルド</h2>

<h3>対象バージョン</h3>

<p>
本書で解説している<code>ruby</code>のバージョンは1.7の2002-09-12版である。<code>ruby</code>はマ
イナーバージョンが偶数だと安定版で奇数だと開発版だから、1.7は開発版と
いうことになる。しかも9月12日は特に何かの区切りというわけではないの
で、該当バージョンの公式パッケージは配布されていない。従ってこの版を入
手するには本書添付のCD-ROMまたはサポートサイト
\footnote{本書のサポートサイト……<code>http://i.loveruby.net/ja/rhg/</code>}
から入手するか、後述のCVSを使うしかない。
</p>

<p>
安定版の1.6でなく1.7にした理由は、1.7のほうが仕様・実装ともに整理され
ていて扱いやすいことが一つ。次に、開発版先端のほうがCVSが使いやすい。
さらに、わりと近いうちに次の安定版の1.8が出そうな雰囲気になってきたこと。
そして最後に、最先端を見ていくほうが気分的に楽しい。
</p>



<h3>ソースコードを入手する</h3>

<p>
添付CD-ROMに解説対象の版のアーカイブを収録した。
CD-ROMのトップディレクトリに
</p>

<pre class="emlist">
ruby-rhg.tar.gz
ruby-rhg.zip
ruby-rhg.lzh
</pre>

<p>
の三種類が置いてあるので、便利なものを選んで使ってほしい。
もちろん中身はどれも同じだ。例えば<code>tar.gz</code>のアーカイブなら
次のように展開すればいいだろう。
</p>

<pre class="screen">
~/src % mount /mnt/cdrom
~/src % gzip -dc /mnt/cdrom/ruby-rhg.tar.gz | tar xf -
~/src % umount /mnt/cdrom
</pre>



<h3>コンパイルする</h3>

<p>
ソースコードを見るだけでも「読む」ことはできる。しかしプログラムを知る
ためには実際にそれを使い、改造し、実験してみることが必要だ。実験をする
なら見ているソースコードと同じものを使わなければ意味がないので、当然自
分でコンパイルすることになる。
</p>

<p>
そこでここからはコンパイルの方法を説明する。まずはUNIX系OSの場合から話
を始めよう。Windows上ではいろいろあるので次の項でまとめて話す。ただし
CygwinはWindows上ではあるがほとんどUNIXなので、こちらの話を読んでほし
い。
</p>

<h4>UNIX系OSでのビルド</h4>

<p>
さて、UNIX系OSなら普通Cコンパイラは標準装備なので、次の手順でやれば
たいがい通ってしまう。
<code>~/src/ruby</code>にソースコードが展開されているとする。
</p>

<pre class="screen">
~/src/ruby % ./configure
~/src/ruby % make
~/src/ruby % su
~/src/ruby # make install
</pre>

<p>
以下、いくつか注意すべき点を述べる。
</p>

<p>
Cygwin、UX/4800など一部のプラットフォームでは<code>configure</code>の段階で
<code>--enable-shared</code>オプションを付けないとリンクに失敗する。
<code>--enable-shared</code>というのは<code>ruby</code>のほとんどを共有ライブラリ
（<code>libruby.so</code>）としてコマンドの外に出すオプションである。
</p>

<pre class="screen">
~/src/ruby % ./configure --enable-shared
</pre>

<p>
ビルドに関するより詳しいチュートリアルを添付CD-ROMの
<code>doc/build.html</code>に入れたので、それを読みながらやってみてほしい。
</p>

<h4>Windowsでのビルド</h4>

<p>
Windowsでのビルドとなるとどうも話がややこしくなる。
問題の根源はビルド環境が複数あることだ。
</p>

<ul>
<li>Visual C++</li>
<li>MinGW</li>
<li>Cygwin</li>
<li>Borland C++ Compiler</li>
</ul>

<p>
まずCygwin環境はWindowsよりもUNIXに条件が近いのでUNIX系のビルド手順に
従えばいい。
</p>

<p>
Visual C++でコンパイルする場合はVisual C++ 5.0以上が
必要である。バージョン6か.NETならまず問題ないだろう。
</p>

<p>
MinGW、Minimalist GNU for WindowsというのはGNUのコンパイル環境（ようするに
<code>gcc</code>と<code>binutils</code>）をWindowsに移植したものだ。CygwinがUNIX環境全体を移植し
たのに対し、MinGWはあくまでコンパイルのためのツールだけを移植してある。
またMinGWでコンパイルしたプログラムは実行時に特別なDLLを必要としない。
つまりMinGWでコンパイルした<code>ruby</code>はVisual C++版と全く同じに扱える。
</p>

<p>
また個人利用ならばBorland C++ Compilerのバージョン5.5がBorlandのサイト
\footnote{Borlandのサイト：<code>http://www.borland.co.jp</code>}
から無料でダウンロードできる。<code>ruby</code>がサポートしたのがかなり最近なのが
多少不安だが、本書出版前に行ったビルドテストでは特に問題は出ていない。
</p>

<p>
さて以上四つの環境のうちどれを選べばいいだろうか。まず基本的には
Visual C++版が最も問題が出にくいのでそれをお勧めする。UNIXの経験がある
ならCygwin一式入れてCygwinを使うのもよい。UNIXの経験がなくVisual C++も
持っていない場合はMinGWを使うのがいいだろう。
</p>

<p>
以下ではVisual C++とMinGWでのビルド方法について説明するが、
あくまで概要だけに留めた。より細かい解説とBorland C++ Compilerでの
ビルド方法は添付CD-ROMの<code>doc/build.html</code>に収録したので適宜そちらも
参照してほしい。
</p>

<h4>Visual C++</h4>

<p>
Visual C++と言っても普通はIDEは使わず、DOSプロンプトからビルドする。そ
のときはまずVisual C++自体を動かせるようにするために環境変数の初期化を
しなければいけない。Visual C++にそのためのバッチファイルが付いてくるの
で、まずはそれを実行しよう。
</p>

<pre class="screen">
C:\&gt; cd "\Program Files\Microsoft Visual Studio .NET\Vc7\bin"
C:\Program Files\Microsoft Visual Studio .NET\Vc7\bin&gt; vcvars32
</pre>

<p>
これはVisual C++.NETの場合だ。バージョン6なら以下の場所にある。
</p>

<pre class="emlist">
C:\Program Files\Microsoft Visual Studio\VC98\bin\
</pre>

<p>
<code>vcvars32</code>を実行したらその後は<code>ruby</code>のソースツリーの中のフォルダ
<code>win32\</code>に移動してビルドすればいい。以下、ソースツリーは<code>C:\src</code>に
あるとしよう。
</p>

<pre class="screen">
C:\&gt; cd src\ruby
C:\src\ruby&gt; cd win32
C:\src\ruby\win32&gt; configure
C:\src\ruby\win32&gt; nmake
C:\src\ruby\win32&gt; nmake DESTDIR="C:\Program Files\ruby" install
</pre>

<p>
これで<code>C:\Program Files\ruby\bin\</code>に<code>ruby</code>コマンドが、
<code>C:\Program Files\ruby\lib\</code>以下にRubyのライブラリが、
それぞれインストールされる。<code>ruby</code>はレジストリなどは一切使わない
ので、アンインストールするときは<code>C:\ruby</code>以下を消せばよい。
</p>

<h4>MinGW</h4>

<p>
前述のようにMinGWはコンパイル環境のみなので、一般的なUNIXのツール、
例えば<code>sed</code>や<code>sh</code>が存在しない。しかし<code>ruby</code>のビルドにはそれが必要なので
それをどこかから調達しなければならない。それにはまた二つの方法が
存在する。CygwinとMSYS（Minimal SYStem）である。
</p>

<p>
だがMSYSのほうは本書の出版前に行ったビルド大会でトラブルが続出してしまっ
たのでお勧めできない。対照的にCygwinを使う方法だと非常に素直に通った。
従って本書ではCygwinを使う方法を説明する。
</p>

<p>
まずCygwinの<code>setup.exe</code>でMinGWと開発ツール一式を入れておく。
CygwinとMinGWは添付CD-ROMにも収録した
\footnote{CygwinとMinGW……添付CD-ROMの<code>doc/win.html</code>を参照}。
あとはCygwinの<code>bash</code>プロンプトから以下のように打てばよい。
</p>

<pre class="screen">
~/src/ruby % ./configure --with-gcc='gcc -mno-cygwin' \
                                 --enable-shared i386-mingw32
~/src/ruby % make
~/src/ruby % make install
</pre>

<p>
これだけだ。ここでは<code>configure</code>の行を折り返しているが実際には一行に
入れる。またバックスラッシュを入れる必要はない。インストール先は
コンパイルしたドライブの<code>\usr\local\</code>以下になる。このあたりはかなり
ややこしいことが起こっていて説明が長くなるので、
添付CD-ROMの<code>doc/build.html</code>で徹底的に説明しよう。
</p>































<h2>ビルド詳細</h2>

<p>
ここまでが<code>README</code>的な解説である。今度はこれまでやったことが具体的に
何をしているのか、つっこんで見ていこう。ただしここの話は部分的に
かなり高度な知識が必要になる。わからない場合はいきなり次の節に
飛んでほしい。本書全体を読んでから戻ってきてもらえばわかるように
なっているはずだ。
</p>

<p>
さて、どのプラットフォームでも<code>ruby</code>のビルドは三段階に分かれている。
即ち<code>configure</code>、<code>make</code>、<code>make install</code>だ。<code>make install</code>はいいとして、
<code>configure</code>と<code>make</code>の段階について解説しよう。
</p>

<h3><code>configure</code></h3>

<p>
まず<code>configure</code>である。この中身はシェルスクリプトになっており、これ
でシステムのパラメータを検出する。例えば「ヘッダファイル<code>setjmp.h</code>が存
在するか」とか、「<code>alloca()</code>は使えるか」ということを調べてくれる。調べ
る方法は意外と単純である。
</p>

<table>
<tr><td>チェック対象<td><td>方法<td></tr>
<tr><td>コマンド<td><td>実際に実行してみて<code>$?</code>を見る<td></tr>
<tr><td>ヘッダファイル<td><td><code>if [ -f $includedir/stdio.h ]</code><td></tr>
<tr><td>関数<td><td>小さいプログラムをコンパイルしてみてリンクが成功するかどうか試す<td></tr>
</table>

<p>
違いを検出したら、それをどうにかしてこちらに伝えてもらわないと
いけない。その方法は、まず<code>Makefile</code>が一つ。パラメータを<code>@PARAM@</code>の
ように埋め込んだ<code>Makefile.in</code>を置いておくと、それを実際の値に変換
した<code>Makefile</code>を生成してくれる。例えば次のように。
</p>

<pre class="emlist">
Makefile.in:  CFLAGS = @CFLAGS@
                     ↓
Makefile   :  CFLAGS = -g -O2
</pre>

<p>
もう一つ、関数やヘッダファイルがあるかどうかといった情報を
ヘッダファイルにして出力してくれる。出力ファイルの名前は変更
できるのでプログラムによって違うが、<code>ruby</code>では<code>config.h</code>である。
<code>configure</code>を実行した後にこのファイルができていることを確かめてほしい。
中身はこんな感じだ。
</p>

<p class="caption">▼<code>config.h</code></p>
<pre class="longlist">
         ：
         ：
#define HAVE_SYS_STAT_H 1
#define HAVE_STDLIB_H 1
#define HAVE_STRING_H 1
#define HAVE_MEMORY_H 1
#define HAVE_STRINGS_H 1
#define HAVE_INTTYPES_H 1
#define HAVE_STDINT_H 1
#define HAVE_UNISTD_H 1
#define _FILE_OFFSET_BITS 64
#define HAVE_LONG_LONG 1
#define HAVE_OFF_T 1
#define SIZEOF_INT 4
#define SIZEOF_SHORT 2
         ：
         ：
</pre>


<p>
どれも意味はわかりやすい。<code>HAVE_xxxx_H</code>ならヘッダファイルが存在するか
どうかのチェックだろうし、<code>SIZEOF_SHORT</code>ならCの<code>short</code>型が何バイトかを
示しているに違いない。同じく<code>SIZEOF_INT</code>なら<code>int</code>のバイト長だし、
<code>HAVE_OFF_T</code>は<code>offset_t</code>型が定義されているかを示している。これに限らず
<code>configure</code>では「ある／ない」の情報は<code>HAVE_xxxx</code>というマクロで定義される
（する）。
</p>

<p>
以上のことからわかるように、<code>configure</code>は違いを検出してはくれるが、
その違いを自動的に吸収してくれるわけではない。ここで定義された値を
使って差を埋めるのはあくまで各プログラマの仕事である。例えば次の
ように。
</p>

<p class="caption">▼<code>HAVE_</code>マクロの典型的な使いかた</p>
<pre class="longlist">
  24  #ifdef HAVE_STDLIB_H
  25  # include &lt;stdlib.h&gt;
  26  #endif

(ruby.h)
</pre>




<h3><code>autoconf</code></h3>

<p>
<code>configure</code>は<code>ruby</code>の専用ツールではない。関数があるか、ヘッダファイルが
あるか……といったテストには明らかに規則性があるのだから、プログラムを
書く人がみんなでそれぞれに別のものを書くのは無駄だ。
</p>

<p>
そこで登場するのが<code>autoconf</code>というツールである。<code>configure.in</code>とか
<code>configure.ac</code>というファイルに「こういうチェックがしたいんだ」と
書いておき、それを<code>autoconf</code>で処理すると適切な<code>configure</code>を作ってくれる。
<code>configure.in</code>の<code>.in</code>は<code>input</code>の略だろう。<code>Makefile</code>と<code>Makefile.in</code>の関係と
同じである。<code>.ac</code>のほうはもちろん<code>AutoConf</code>の略だ。
</p>

<p>
ここまでを絵にすると図1のようになる。
</p>

<p class="image">
<img src="images/ch_abstract_build.jpg" alt="(build)"><br>
図1: <code>Makefile</code>ができるまで
</p>

<p>
もっと詳しいことが知りたい読者には『GNU Autoconf/Automake/Libtool』
\footnote{『GNU Autoconf/Automake/Libtool』Gary V.Vaughan, Ben Elliston, Tom Tromey, Ian Lance Taylor共著、でびあんぐる監訳、オーム社}
をお勧めする。
</p>

<p>
ところで<code>ruby</code>の<code>configure</code>は言ったとおり<code>autoconf</code>を使って生成してい
るのだが、世の中にある<code>configure</code>が必ずしも<code>autoconf</code>で生成されている
とは限らない。手書きだったり、別の自動生成ツールを使っていたりすること
もある。なんにせよ、最終的に<code>Makefile</code>や<code>config.h</code>やその他いろいろがで
きればそれでいいのだ。
</p>



<h3><code>make</code></h3>

<p>
第二段階、<code>make</code>では何をするのだろうか。もちろん<code>ruby</code>のソースコードを
コンパイルするわけだが、<code>make</code>の出力を見ているとどうもその他にいろいろ
やっているように見える。その過程を簡単に説明しておこう。
</p>

<ol>
<li><code>ruby</code>自体を構成するソースコードをコンパイルする。</li>
<li><code>ruby</code>の主要部分を集めたスタティックライブラリ<code>libruby.a</code>を作る。</li>
<li>常にスタティックリンクされる<code>ruby</code>「<code>miniruby</code>」を作る。</li>
<li><code>--enable-shared</code>のときは共有ライブラリ<code>libruby.so</code>を作る。</li>
<li><code>miniruby</code>を使って拡張ライブラリ（<code>ext/</code>以下）をコンパイルする。</li>
<li>最後に、本物の<code>ruby</code>を生成する。</li>
</ol>

<p>
<code>miniruby</code>と<code>ruby</code>の生成が分かれているのには二つ理由がある。一つめは拡張ラ
イブラリのコンパイルに<code>ruby</code>が必要になることだ。<code>--enable-shared</code>の場合は
<code>ruby</code>自身がダイナミックリンクされるので、ライブラリのロードパスの関係で
すぐに動かせないかもしれない。そこでスタティックリンクした<code>miniruby</code>を作り、
ビルドの過程ではそちらを使うようにする。
</p>

<p>
二つめの理由は、共有ライブラリが使えないプラットフォームでは拡張ライブ
ラリを<code>ruby</code>自体にスタティックリンクしてしまう場合があるということだ。そ
の場合、<code>ruby</code>は拡張ライブラリを全てコンパイルしてからでないと作れないが、
拡張ライブラリは<code>ruby</code>がないとコンパイルできない。そのジレンマを解消する
ために<code>miniruby</code>を使うのである。
</p>






















<h2>CVS</h2>

<p>
本書の添付CD-ROMに入っている<code>ruby</code>のアーカイブにしても公式のリリースパッ
ケージにしても、それは<code>ruby</code>という、変化しつづているプログラムのほんの一
瞬の姿をとらえたスナップショットにすぎない。<code>ruby</code>がどう変わってきたか、
どうしてそうだったのか、ということはここには記述されていない。では過去
も含めた全体を見るにはどうしたらいいだろうか。CVSを使えばそれができる。
</p>

<h3>CVSとは</h3>

<p>
CVSを一言で言うとエディタのundoリストである。
ソースコードをCVSの管理下に入れておけばいつでも昔の姿に戻せるし、誰が、
どこを、いつ、どう変えたのかすぐにわかる。一般にそういうことをしてくれ
るプログラムのことをソースコード管理システムと言うが、オープンソースの
世界で一番有名なソースコード管理システムがCVSである。
</p>

<p>
<code>ruby</code>もやはりCVSで管理されているのでCVSの仕組みと使いかたについて少し説
明しよう。まずCVSの最重要概念はレポジトリとワーキングコピーである。
CVSはエディタのundoリストのようなものと言ったが、そのためには歴代の変更の
記録を
どこかに残しておかないといけない。それを全部まとめて保存しておく場所が
「CVSレポジトリ」である。
</p>

<p>
ぶっちゃけて言うと、過去のソースコードを全部集めてあるのがレポジトリで
ある。もちろんそれはあくまで概念であって、実際には容量を節約するために、
最新の姿一つと、そこに至るまでの変更差分（ようするにパッチ）の形で集積
されている。なんにしてもファイルの過去の姿をどの時点だろうと取り出せる
ようになっていればそれでいいのだ。
</p>

<p>
一方、レポジトリからある一点を選んでファイルを取り出したものが
「ワーキングコピー」だ。レポジトリは一つだけだがワーキングコピーは
いくつあってもいい（図2）。
</p>

<p class="image">
<img src="images/ch_abstract_repo.jpg" alt="(repo)"><br>
図2: レポジトリとワーキングコピー
</p>

<p>
自分がソースコードを変更したいときはまずワーキングコピーを取り出して、
それをエディタなどで編集してからレポジトリに「戻す」。するとレポジトリ
に変更が記録される。レポジトリからワーキングコピーを取り出すことを
「チェックアウト（checkout）」、戻すことを「チェックイン
（checkin）」
または「コミット（commit）」と言う（図3）。チェックインするとレ
ポジトリに変更が記録されて、いつでもそれを取り出せるようになる。
</p>

<p class="image">
<img src="images/ch_abstract_ci.jpg" alt="(ci)"><br>
図3: チェックインとチェックアウト
</p>

<p>
そしてCVS最大の特徴はCVSレポジトリにネットワーク越しにアクセスできると
いうところだ。つまりレポジトリを保持するサーバが一つあればインターネッ
ト越しに誰でもどこからでもチェックアウト・チェックインすることができる。
ただし普通はチェックインにはアクセス制限がかかっているので無制限
にできるというわけではない。
</p>

<h4>リビジョン</h4>

<p>
レポジトリから特定の版を取り出すにはどうしたらいいだろうか。一つには時
刻で指定する方法がある。「この当時の最新版をくれ」と要求するとそれを選
んでくれるわけだ。しかし実際には時刻で指定することはあまりない。普通は
「リビジョン（revision）」というものを使う。
</p>

<p>
「リビジョン」は「バージョン」とほとんど同じ意味である。ただ普通はプロ
ジェクト自体に「バージョン」が付いているので、バージョンという言葉を使
うと紛らわしい。そこでもうちょっと細かい単位を意図してリビジョンという
言葉を使う。
</p>

<p>
CVSでは、レポジトリに入れたばかりのファイルはリビジョン1.1である。
チェックアウトして、変更して、チェックインするとリビジョン1.2になる。
その次は1.3になる。その次は1.4になる。
</p>

<h4>CVSの簡単な使用例</h4>

<p>
以上をふまえてごくごく簡単にCVSの使いかたを話す。まず<code>cvs</code>コマンドがな
いとどうにもならないのでインストールしておいてほしい。添付CD-ROMにも
<code>cvs</code>のソースコードを収録した
\footnote{<code>cvs</code>：<code>archives/cvs-1.11.2.tar.gz</code>}。
<code>cvs</code>のインストールの方法はあまりにも本筋から外れるのでここでは書かな
い。
</p>

<p>
インストールしたら試しに<code>ruby</code>のソースコードをチェックアウトしてみよう。
インターネットに接続中に次のように打つ。
</p>

<pre class="screen">
% cvs -d :pserver:anonymous@cvs.ruby-lang.org:/src login
CVS Password: anonymous
% cvs -d :pserver:anonymous@cvs.ruby-lang.org:/src checkout ruby
</pre>

<p>
何もオプションを付けないと自動的に最新版がチェックアウトされるので、
<code>ruby/</code>以下に<code>ruby</code>の真の最新版が現れているはずだ。
</p>

<p>
また、とある日の版を取り出すには<code>cvs checkout</code>に<code>-D</code>オプションをつけれ
ばいい。次のように打てば本書が解説しているバージョンのワーキングコピー
が取り出せる。
</p>

<pre class="screen">
% cvs -d :pserver:anonymous@cvs.ruby-lang.org:/src checkout -D2002-09-12 ruby
</pre>

<p>
このとき、オプションは必ず<code>checkout</code>の直後に書かないといけないことに注
意。先に「<code>ruby</code>」を書いてしまうと「モジュールがない」という変なエラー
になる。
</p>

<p>
ちなみにこの例のようなanonymousアクセスだとチェックインはできないようになっている。
チェックインの練習をするには適当に（ローカルの）レポジトリを作って
Hello, World!プログラムでも入れてみるのがいいだろう。具体的な入れかた
はここには書かない。<code>cvs</code>に付いてくるマニュアルが結構親切だ。日本語の書
籍ならオーム社の『CVSによるオープンソース開発』
\footnote{『CVSによるオープンソース開発』Karl Fogel, Moshe Bar共著、竹内利佳訳、オーム社}
をお勧めする。
</p>































<h2><code>ruby</code>の構成</h2>

<h3>物理構造</h3>

<p>
さてそろそろソースコードを見ていこうと思うのだが、まず最初にしなければ
ならないことはなんだろうか。それはディレクトリ構造を眺めることである。
たいていの場合ディレクトリ構造すなわちソースツリーはそのままプログラム
のモジュール構造を示している。いきなり<code>grep</code>で<code>main()</code>を探して頭から処理順
に読んでいく、なんていうのは賢くない。もちろん<code>main()</code>を探すのも大切だが、
まずはのんびりと<code>ls</code>したり<code>head</code>したりして全体の様子をつかもう。
</p>

<p>
以下はCVSレポジトリからチェックアウトした直後の
トップディレクトリの様子だ。
スラッシュで終わっているのはサブディレクトリである。
</p>

<pre class="emlist">
COPYING        compar.c       gc.c           numeric.c      sample/
COPYING.ja     config.guess   hash.c         object.c       signal.c
CVS/           config.sub     inits.c        pack.c         sprintf.c
ChangeLog      configure.in   install-sh     parse.y        st.c
GPL            cygwin/        instruby.rb    prec.c         st.h
LEGAL          defines.h      intern.h       process.c      string.c
LGPL           dir.c          io.c           random.c       struct.c
MANIFEST       djgpp/         keywords       range.c        time.c
Makefile.in    dln.c          lex.c          re.c           util.c
README         dln.h          lib/           re.h           util.h
README.EXT     dmyext.c       main.c         regex.c        variable.c
README.EXT.ja  doc/           marshal.c      regex.h        version.c
README.ja      enum.c         math.c         ruby.1         version.h
ToDo           env.h          misc/          ruby.c         vms/
array.c        error.c        missing/       ruby.h         win32/
bcc32/         eval.c         missing.h      rubyio.h       x68/
bignum.c       ext/           mkconfig.rb    rubysig.h
class.c        file.c         node.h         rubytest.rb
</pre>

<p>
最近はプログラム自体が大きくなってきてサブディレクトリが細かく分割され
ているソフトウェアも多いが、<code>ruby</code>はかなり長いことトップディレクトリ
一筋である。あまりにファイル数が多いと困るが、この程度なら慣れればな
んでもない。
</p>

<p>
トップレベルのファイルは六つに分類できる。即ち
</p>

<ul>
<li>ドキュメント</li>
<li><code>ruby</code>自身のソースコード</li>
<li><code>ruby</code>ビルド用のツール</li>
<li>標準添付拡張ライブラリ</li>
<li>標準添付Rubyライブラリ</li>
<li>その他</li>
</ul>

<p>
である。ソースコードとビルドツールが重要なのは当然として、その他に
我々の役に立ちそうなものを挙げておこう。
</p>

<ul>
<li><code>ChangeLog</code></li>
</ul>

<p>
<code>ruby</code>への変更の記録。変更の理由を調べるうえでは非常に重要。
</p>

<ul>
<li><code>README.EXT README.EXT.ja</code></li>
</ul>

<p>
拡張ライブラリの作成方法が書いてあるのだが、その一環として
<code>ruby</code>自身の実装に関することも書いてある。
</p>



<h3>ソースコードの腑分け</h3>

<p>
ここからは<code>ruby</code>自身のソースコードについてさらに細かく分割していく。
主要なファイルについては<code>README.EXT</code>に分類が書いてあったので
それに従う。記載がないものは筆者が分類した。
</p>

<h4>Ruby言語のコア</h4>

<table>
<tr><td><code>class.c</code><td><td>クラス関連API<td></tr>
<tr><td><code>error.c</code><td><td>例外関連API<td></tr>
<tr><td><code>eval.c</code><td><td>評価器<td></tr>
<tr><td><code>gc.c</code><td><td>ガーベージコレクタ<td></tr>
<tr><td><code>lex.c</code><td><td>予約語テーブル<td></tr>
<tr><td><code>object.c</code><td><td>オブジェクトシステム<td></tr>
<tr><td><code>parse.y</code><td><td>パーサ<td></tr>
<tr><td><code>variable.c</code><td><td>定数、グローバル変数、クラス変数<td></tr>
<tr><td><code>ruby.h</code><td><td><code>ruby</code>の主要マクロとプロトタイプ<td></tr>
<tr><td><code>intern.h</code><td><td><code>ruby</code>のC APIのプロトタイプ。<code>intern</code>はinternalの略だと思われるが、ここに載っている関数を拡張ライブラリで使うのは別に構わない。<td></tr>
<tr><td><code>rubysig.h</code><td><td>シグナル関係のマクロを収めたヘッダファイル<td></tr>
<tr><td><code>node.h</code><td><td>構文木ノード関連の定義<td></tr>
<tr><td><code>env.h</code><td><td>評価器のコンテキストを表現する構造体の定義<td></tr>
</table>

<p>
<code>ruby</code>インタプリタのコアを構成する部分。本書が解説するのは
ここのファイルがほとんどである。<code>ruby</code>全体のファイル数と比べれば
非常に少ないが、バイトベースでは全体の50%近くを占める。
特に<code>eval.c</code>は200Kバイト、<code>parse.y</code>が100Kバイトと大きい。
</p>

<h4>ユーティリティ</h4>

<table>
<tr><td><code>dln.c</code><td><td>動的ローダ<td></tr>
<tr><td><code>regex.c</code><td><td>正規表現エンジン<td></tr>
<tr><td><code>st.c</code><td><td>ハッシュテーブル<td></tr>
<tr><td><code>util.c</code><td><td>基数変換やソートなどのライブラリ<td></tr>
</table>

<p>
<code>ruby</code>にとってのユーティリティという意味。ただしユーティリティという
言葉からは想像できないほど大きいものもある。例えば<code>regex.c</code>は120Kバイトだ。
</p>

<h4><code>ruby</code>コマンドの実装</h4>

<table>
<tr><td><code>dmyext.c</code><td><td>拡張ライブラリ初期化ルーチンのダミー（DumMY EXTention）<td></tr>
<tr><td><code>inits.c</code><td><td>コアとライブラリの初期化ルーチンのエントリポイント<td></tr>
<tr><td><code>main.c</code><td><td>コマンドのエントリポイント（<code>libruby</code>には不要）<td></tr>
<tr><td><code>ruby.c</code><td><td><code>ruby</code>コマンドの主要部分（<code>libruby</code>にも必要）<td></tr>
<tr><td><code>version.c</code><td><td><code>ruby</code>のバージョン<td></tr>
</table>

<p>
コマンドラインで<code>ruby</code>と打って実行するときの<code>ruby</code>コマンドの実装。コマンドライン
オプションの解釈などを行っている部分だ。<code>ruby</code>コマンド以外に<code>ruby</code>コアを利
用するコマンドとしては<code>mod_ruby</code>や<code>vim</code>が挙げられる。これらのコマンドは
ライブラリ<code>libruby</code>（<code>.a</code>/<code>.so</code>/<code>.dll</code>など）とリンクして動作する。
</p>

<h4>クラスライブラリ</h4>

<table>
<tr><td><code>array.c</code><td><td><code>class Array</code><td></tr>
<tr><td><code>bignum.c</code><td><td><code>class Bignum</code><td></tr>
<tr><td><code>compar.c</code><td><td><code>module Comparable</code><td></tr>
<tr><td><code>dir.c</code><td><td><code>class Dir</code><td></tr>
<tr><td><code>enum.c</code><td><td><code>module Enumerable</code><td></tr>
<tr><td><code>file.c</code><td><td><code>class File</code><td></tr>
<tr><td><code>hash.c</code><td><td><code>class Hash</code>（実体は<code>st.c</code>）<td></tr>
<tr><td><code>io.c</code><td><td><code>class IO</code><td></tr>
<tr><td><code>marshal.c</code><td><td><code>module Marshal</code><td></tr>
<tr><td><code>math.c</code><td><td><code>module Math</code><td></tr>
<tr><td><code>numeric.c</code><td><td><code>class Numeric</code>、<code>Integer</code>、<code>Fixnum</code>、<code>Float</code><td></tr>
<tr><td><code>pack.c</code><td><td><code>Array#pack</code>、<code>String#unpack</code><td></tr>
<tr><td><code>prec.c</code><td><td><code>module Precision</code><td></tr>
<tr><td><code>process.c</code><td><td><code>module Process</code><td></tr>
<tr><td><code>random.c</code><td><td><code>Kernel#srand()</code>、<code>rand()</code><td></tr>
<tr><td><code>range.c</code><td><td><code>class Range</code><td></tr>
<tr><td><code>re.c</code><td><td><code>class Regexp</code>（実体は<code>regex.c</code>）<td></tr>
<tr><td><code>signal.c</code><td><td><code>module Signal</code><td></tr>
<tr><td><code>sprintf.c</code><td><td><code>ruby</code>専用の<code>sprintf()</code><td></tr>
<tr><td><code>string.c</code><td><td><code>class String</code><td></tr>
<tr><td><code>struct.c</code><td><td><code>class Struct</code><td></tr>
<tr><td><code>time.c</code><td><td><code>class Time</code><td></tr>
</table>

<p>
Rubyのクラスライブラリの実装。ここにあるものは基本的に通常の
Ruby拡張ライブラリと全く同じ方法で実装されている。つまりこの
ライブラリが拡張ライブラリの書きかたの例にもなっているということだ。
</p>

<h4>プラットフォーム依存ファイル</h4>

<table>
<tr><td><code>bcc32/</code><td><td>Borland C++（Win32）<td></tr>
<tr><td><code>beos/</code><td><td>BeOS<td></tr>
<tr><td><code>cygwin/</code><td><td>Cygwin（Win32でのUNIXエミュレーションレイヤー）<td></tr>
<tr><td><code>djgpp/</code><td><td>djgpp（DOS用のフリーな開発環境）<td></tr>
<tr><td><code>vms/</code><td><td>VMS（かつてDECがリリースしていたOS）<td></tr>
<tr><td><code>win32/</code><td><td>Visual C++（Win32）<td></tr>
<tr><td><code>x68/</code><td><td>Sharp X680x0系（OSはHuman68k）<td></tr>
</table>

<p>
各プラットフォーム特有のコードが入っている。
</p>

<h4>フォールバック関数</h4>

<pre class="emlist">
missing/
</pre>

<p>
各種プラットフォームにない関数を補うためのファイル。
主に<code>libc</code>の関数が多い。
</p>




<h3>論理構造</h3>

<p>
さて、以上四つのグループのうちコアはさらに大きく三つに分けられる。
一つめはRubyのオブジェクト世界を作りだす「オブジェクト空間（object space）」。
二つめはRubyプログラム（テキスト）を内部形式に変換する「パーサ（parser）」。
三つめはRubyプログラムを駆動する「評価器（evaluator）」。
パーサも評価器もオブジェクト空間の上に成立し、
パーサがプログラムを内部形式に変換し、
評価器がプログラムを駆動する。
順番に解説していこう。
</p>

<h4>オブジェクト空間</h4>

<p>
一つめのオブジェクト空間。これは非常に、理解しやすい。なぜならこれが扱
うものは基本的にメモリ上のモノが全てであり、関数を使って直接表示したり
操作したりすることができるからだ。従って本書ではまずここから解説を
始める。第2章から
第7章までが第一部である。
</p>

<h4>パーサ</h4>

<p>
二つめのパーサ。これは説明が必要だろう。
</p>

<p>
<code>ruby</code>コマンドはRuby言語のインタプリタである。つまり起動時にテキストの入
力を解析し、それに従って実行する。だから<code>ruby</code>はテキストとして書かれたプ
ログラムの意味を解釈できなければいけないのだが、不幸にしてテキストとい
うのはコンピュータにとっては非常に理解しづらいものである。コンピュータ
にとってはテキストファイルはあくまでバイト列であって、それ以上ではない。
そこからテキストの意味を読みとるには何か特別な仕掛けが必要になる。そ
の仕掛けがパーサだ。このパーサを通すことでRubyプログラム（であるテキス
ト）は<code>ruby</code>専用の、プログラムから扱いやすい内部表現に変換される。
</p>

<p>
その内部表現とは具体的には「構文木」というものだ。構文木はプログラムを
ツリー構造で表現したもので、例えば<code>if</code>文ならば図4のように
表現される。
</p>

<p class="image">
<img src="images/ch_abstract_syntree.jpg" alt="(syntree)"><br>
図4: <code>if</code>文と、それに対応する構文木
</p>

<p>
パーサの解説は第二部『構文解析』で行う。
第二部は第10章から第12章までだ。
対象となるファイルは<code>parse.y</code>だけである。
</p>

<h4>評価器</h4>

<p>
オブジェクトは実際に触ることができるのでわかりやすい。パーサにしてもやっ
ていること自体はようするにデータ形式の変換なんだから、まあわかる。しか
し三つめの評価器、こいつはつかみどころが全くない。
</p>

<p>
評価器がやるのは構文木に従ってプログラムを「実行」していくことだ。と言
うと簡単そうに見えるのだが、では「実行する」とはどういうことか、ちゃん
と考えるとこれが結構難しい。<code>if</code>文を実行するとはどういうことだろうか。
<code>while</code>文を実行するとはどういうことだろうか。ローカル変数に代入するとは
どういうことだろうか。メソッドを呼ぶとはどういうことだろうか。その
全てにキチンキチンと答えを出していかなければ評価器はわからないのだ。
</p>

<p>
本書では第三部『評価』で評価器を扱う。対象ファイルは<code>eval.c</code>だ。
「評価器」は英語でevaluatorと言うので、それを省略して<code>eval</code>である。

<p>
さて、<code>ruby</code>の作りについて簡単に説明してきたが、プログラムの動作なんてい
くら概念を説明してもわかりにくいものだ。次の章ではまず実際に<code>ruby</code>を使う
ことから始めるとしよう。

<hr>
<p>
御意見・御感想・誤殖の指摘などは
<a href="mailto:aamine@loveruby.net">青木峰郎 &lt;aamine@loveruby.net&gt;</a>
までお願いします。
</p>
<p>
<a href="http://direct.ips.co.jp/directsys/go_x_TempChoice.cfm?sh_id=EE0040&amp;spm_id=1&amp;GM_ID=1721">『Rubyソースコード完全解説』
はインプレスダイレクトで御予約・御購入いただけます (書籍紹介ページへ飛びます)。</a>
</p>
<p>Copyright (c) 2002-2004 Minero Aoki, All rights reserved.</p>

</body>
</html>
